package main

import (
	"os"
	"encoding/json"
	"sort"
	"strconv"
	"fmt"
)

// KeyValue is a type used to hold the key/value pairs passed to the map and
// reduce functions.
type KeyValue struct {
	Key   string
	Value string
}

// reduceName constructs the name of the intermediate file which map task
// <mapTask> produces for reduce task <reduceTask>.
func reduceName(mapID int, reduceID int) string {
        return "maptmp-" + strconv.Itoa(mapID)  + "-"  + strconv.Itoa(reduceID) + ".txt"
}

// mergeName constructs the name of the output file of reduce task <reduceTask>
func mergeName(reduceID int) string {
	return "reduceResult-"+ strconv.Itoa(reduceID) + ".txt" 
}

// The reduce function is called once for each key generated by Map, with a
// list of that key's string value (merged across all inputs). The return value
// should be a single output value for that key.
func reduceF(key string, values []string) string {
	// TODO: you also have to write this function
	count := 0
	for _, value := range values {
		num, _ := strconv.ParseInt(value, 10, 64)
		count = count + int(num)
	}
	return strconv.Itoa(count)
}

func doReduce(mapN int, reduceID int) {

	//setp 1,read map generator file ,same key merge put map[string][]string

	kvs := make(map[string][]string)

	for i := 0; i < mapN; i++ {
		fileName := reduceName(i+1, reduceID)
		file, err := os.Open(fileName)
		if err != nil {
			fmt.Println("doReduce1: ", err)
		}

		dec := json.NewDecoder(file)

		for {
			var kv KeyValue
			err = dec.Decode(&kv)
			if err != nil {
				break
			}

			_, ok := kvs[kv.Key]
			if !ok {
				kvs[kv.Key] = []string{}
			}
			kvs[kv.Key] = append(kvs[kv.Key], kv.Value)
		}
		file.Close()
	}

	var keys []string

	for k := range kvs {
		keys = append(keys, k)
	}

   	// 
	//setp 2 sort by keys
	sort.Strings(keys)

	//setp 3 create result file
	p := mergeName(reduceID)
	file, err := os.Create(p)
	if err != nil {
		fmt.Println("doReduce2: create ", err)
	}
	enc := json.NewEncoder(file)

	//setp 4 call user reduce each key of kvs
	for _, k := range keys {
		res := reduceF(k, kvs[k])
		enc.Encode(KeyValue{k, res})
	}

	file.Close()
}

func main() {

	/*
		因为有四个map节点，所以每个reduce节点或获得4个map节点产生的中间文件
	*/

	if len(os.Args) < 2 {
		fmt.Printf("usage: go run reduceNode.go mapN reduceID\n")
	} else {
		mapN, _ := strconv.Atoi(os.Args[1])
		reduceID, _ := strconv.Atoi(os.Args[2])
		doReduce(mapN, reduceID)  // 参数1是map节点的个数 参数2是reduceID
	}
}
